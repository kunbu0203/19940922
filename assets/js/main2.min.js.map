{"version":3,"sources":["assets/js/main2.js"],"names":["$","$video","document","querySelector","$canvas","ctx","getContext","streamObj","front","img","Image","openCam","navigator","mediaDevices","getUserMedia","video","facingMode","width","ideal","then","stream","srcObject","catch","error","alert","message","name","src","addEventListener","videoWidth","height","videoHeight","on","getTracks","forEach","track","stop","faceMesh","FaceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","requestAnimationFrame","clearRect","save","translate","scale","drawImage","image","multiFaceLandmarks","length","landmarks","minX","Infinity","minY","maxX","maxY","point","x","y","Math","min","max","faceArea","topOfHead","window","innerWidth","restore","innerHeight","camera","Camera","onFrame","async","send","start"],"mappings":"AAAAA,EAAE,WACE,MAAMC,EAASC,SAASC,cAAc,uBAChCC,EAAUF,SAASC,cAAc,wBACjCE,EAAMD,EAAQE,WAAW,MAC/B,IAAIC,EACAC,GAAQ,EAEZ,MAAMC,EAAM,IAAIC,MAMhB,SAASC,IAELC,UAAUC,aAAaC,aAAa,CAChCC,MAAO,CACHC,WAAYR,EAAQ,OAAS,cAC7BS,MAAO,CAAEC,MAAO,SAErBC,KAAK,SAAUC,GACdb,EAAYa,EACZnB,EAAOoB,UAAYD,IACpBE,MAAM,SAAUC,GACfC,MAAM,eAAgBD,EAAME,QAASF,EAAMG,QAhBnDjB,EAAIkB,IAAM,gCAGVhB,IAiBAV,EAAO2B,iBAAiB,aAAc,WAElCxB,EAAQa,MAAQhB,EAAO4B,WACvBzB,EAAQ0B,OAAS7B,EAAO8B,cACzB,GAEH/B,EAAE,2BAA2BgC,GAAG,QAAS,WACrCzB,EAAU0B,YAAYC,QAAQC,GAASA,EAAMC,QAC7C5B,GAASA,EACTG,MAMJ,MAAM0B,EAAW,IAAIC,SAAS,CAC1BC,WAAaC,wDAA8DA,MAG/EH,EAASI,WAAW,CAChBC,YAAa,EACbC,iBAAiB,EACjBC,uBAAwB,GACxBC,sBAAuB,KAG3BR,EAASS,UAET,SAAmBC,GACfC,sBAAsB,KAsBlB,GApBA3C,EAAI4C,UAAU,EAAG,EAAG7C,EAAQa,MAAOb,EAAQ0B,QAC3CzB,EAAI6C,OACA1C,IAEAH,EAAI8C,UAAU/C,EAAQa,MAAO,GAC7BZ,EAAI+C,OAAO,EAAG,IAElB/C,EAAIgD,UAAUN,EAAQO,MAAO,EAAG,EAAGlD,EAAQa,MAAOb,EAAQ0B,QAatDiB,EAAQQ,oBAA0D,EAApCR,EAAQQ,mBAAmBC,OAAY,CACrE,IAAMC,EAAYV,EAAQQ,mBAAmB,GAG7C,IAAIG,EAAOC,EAAAA,EAAUC,EAAOD,EAAAA,EAAUE,GAAQF,EAAAA,EAAUG,GAAQH,EAAAA,EAChE,IAAK,MAAMI,KAASN,EAAW,CAC3B,IAAMO,EAAID,EAAMC,EAAI5D,EAAQa,MACtBgD,EAAIF,EAAME,EAAI7D,EAAQ0B,OAC5B4B,EAAOQ,KAAKC,IAAIT,EAAMM,GACtBJ,EAAOM,KAAKC,IAAIP,EAAMK,GACtBJ,EAAOK,KAAKE,IAAIP,EAAMG,GACtBF,EAAOI,KAAKE,IAAIN,EAAMG,GAI1B,IAEMI,GAFYR,EAAOH,IACNI,EAAOF,GAIpBR,EAAQc,KAAKE,IAAI,GAAKC,EAAW,KAGjCC,EAAYb,EAAU,IACtBO,EAAIM,EAAUN,EAAI5D,EAAQa,MAC1BgD,EAAIK,EAAUL,EAAI7D,EAAQ0B,OAGhCzB,EAAIgD,UAAU5C,EAAKuD,EAAyB,GAApBO,OAAOC,WAAmBpB,EAAS,EAAGa,EAAyB,GAApBM,OAAOC,WAAmBpB,EAAS,GAAwB,GAApBmB,OAAOC,WAAmBpB,EAA2B,GAApBmB,OAAOC,WAAmBpB,GAGzK/C,EAAIoE,cAKZjD,SAAS+C,OAAOC,eAAeD,OAAOG,eACtC,MAAMC,EAAS,IAAIC,OAAO3E,EAAQ,CAC9B4E,QAASC,gBACCzC,EAAS0C,KAAK,CAAEzB,MAAOrD,KAEjCgB,MAAO,IACPa,OAAQ,IACRd,WAAYR,EAAQ,OAAS,gBAEjCmE,EAAOK","file":"main2.min.js","sourcesContent":["$(function () {\n    const $video = document.querySelector('[data-camera-video]');\n    const $canvas = document.querySelector('[data-camera-canvas]');\n    const ctx = $canvas.getContext('2d');\n    let streamObj; // 預計用來存放 串流相關的物件(MediaStream)\n    let front = true;\n\n    const img = new Image();\n    img.src = './assets/image/touch/logo.png'; // 你想顯示的圖片路徑\n\n    // 開啟 webcam\n    openCam();\n\n    function openCam() {\n        // 開啟視訊鏡頭，瀏覽器會跳詢問視窗\n        navigator.mediaDevices.getUserMedia({\n            video: {\n                facingMode: front ? 'user' : 'environment',\n                width: { ideal: 390 * 3 }\n            }\n        }).then(function (stream) {\n            streamObj = stream;         // 將串流物件放在 streamObj 全域變數，方便後面關閉 webcam 時會用到\n            $video.srcObject = stream;  // video 標籤顯示 webcam 畫面\n        }).catch(function (error) {     // 若無法取得畫面，執行 catch\n            alert('取得相機訪問權限失敗: ', error.message, error.name);\n        });\n    }\n\n    $video.addEventListener('loadeddata', function () {\n        // 將 video 標籤的影片寬高，顯示於 canvas 標籤上\n        $canvas.width = $video.videoWidth;\n        $canvas.height = $video.videoHeight;\n    }, false);\n\n    $('[data-camera-direction]').on('click', function () {\n        streamObj.getTracks().forEach(track => track.stop());\n        front = !front;\n        openCam();\n    });\n\n\n\n\n    const faceMesh = new FaceMesh({\n        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`, // 本地路徑\n    });\n\n    faceMesh.setOptions({\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5,\n    });\n\n    faceMesh.onResults(onResults);\n\n    function onResults(results) {\n        requestAnimationFrame(() => {\n            // 清空Canvas\n            ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n            ctx.save();\n            if (front) {\n                // 水平反轉\n                ctx.translate($canvas.width, 0);\n                ctx.scale(-1, 1);\n            }\n            ctx.drawImage(results.image, 0, 0, $canvas.width, $canvas.height);\n\n            // if (results.multiFaceLandmarks) {\n            //     for (const landmarks of results.multiFaceLandmarks) {\n            //         // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION,\n            //         //     { color: '#C0C0C070', lineWidth: 1 });\n            //         drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030' });\n            //         drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30' });\n            //         drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0' });\n            //         drawConnectors(ctx, landmarks, FACEMESH_LIPS, { color: '#E0E0E0' });\n            //     }\n            // }\n\n            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {\n                const landmarks = results.multiFaceLandmarks[0];\n\n                // 計算臉部的外接矩形範圍\n                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n                for (const point of landmarks) {\n                    const x = point.x * $canvas.width;\n                    const y = point.y * $canvas.height;\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n\n                // 計算臉部面積\n                const faceWidth = maxX - minX;\n                const faceHeight = maxY - minY;\n                const faceArea = faceWidth * faceHeight;\n\n                // 根據面積調整圖片大小，面積越大，頭越近\n                const scale = Math.max(0.2, faceArea / 100000);\n\n                // 計算頭頂的座標\n                const topOfHead = landmarks[10];\n                const x = topOfHead.x * $canvas.width;\n                const y = topOfHead.y * $canvas.height;\n\n                // 根據比例繪製圖片\n                ctx.drawImage(img, x - (window.innerWidth * 0.3 * scale) / 2, y - (window.innerWidth * 0.3 * scale) - 20, window.innerWidth * 0.3 * scale, window.innerWidth * 0.3 * scale);\n            }\n\n            ctx.restore();\n        });\n    }\n\n\n    alert(`${window.innerWidth}, ${window.innerHeight}`);\n    const camera = new Camera($video, {\n        onFrame: async () => {\n            await faceMesh.send({ image: $video });\n        },\n        width: 390,\n        height: 600,\n        facingMode: front ? 'user' : 'environment'\n    });\n    camera.start();\n});"],"sourceRoot":"/"}