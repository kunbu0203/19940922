{"version":3,"sources":["assets/js/main.js"],"names":["$","$video","document","querySelector","$canvas","ctx","getContext","streamObj","front","openCam","navigator","mediaDevices","getUserMedia","video","facingMode","width","ideal","then","stream","srcObject","catch","error","alert","message","name","addEventListener","videoWidth","height","videoHeight","on","getTracks","forEach","track","stop","faceMesh","FaceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","requestAnimationFrame","clearRect","drawImage","image","multiFaceLandmarks","landmarks","drawConnectors","FACEMESH_RIGHT_EYE","color","FACEMESH_LEFT_EYE","FACEMESH_FACE_OVAL","FACEMESH_LIPS","scale","x","y","length","nose","headTop","distance","Math","abs","z","max","img","Image","src","camera","Camera","onFrame","async","send","start"],"mappings":"AAAAA,EAAE,WACE,MAAMC,EAASC,SAASC,cAAc,uBAChCC,EAAUF,SAASC,cAAc,wBACjCE,EAAMD,EAAQE,WAAW,MAC/B,IAAIC,EACAC,GAAQ,EAKZ,SAASC,IAELC,UAAUC,aAAaC,aAAa,CAChCC,MAAO,CACHC,WAAYN,EAAQ,OAAS,cAC7BO,MAAO,CAAEC,MAAO,SAErBC,KAAK,SAAUC,GACdX,EAAYW,EACZjB,EAAOkB,UAAYD,IAEpBE,MAAM,SAAUC,GACfC,MAAM,eAAgBD,EAAME,QAASF,EAAMG,QAdnDf,IAkBAR,EAAOwB,iBAAiB,OAAQ,WAE5BrB,EAAQW,MAAQd,EAAOyB,WACvBtB,EAAQuB,OAAS1B,EAAO2B,cAEzB,GAiBH5B,EAAE,2BAA2B6B,GAAG,QAAS,WACrCtB,EAAUuB,YAAYC,QAAQC,GAASA,EAAMC,QAC7CzB,GAASA,EACTC,MAMJ,MAAMyB,EAAW,IAAIC,SAAS,CAC1BC,WAAaC,wDAA8DA,MAG/EH,EAASI,WAAW,CAChBC,YAAa,EACbC,iBAAiB,EACjBC,uBAAwB,GACxBC,sBAAuB,KAG3BR,EAASS,UAET,SAAmBC,GACfC,sBAAsB,KAIlB,GAHAxC,EAAIyC,UAAU,EAAG,EAAG1C,EAAQW,MAAOX,EAAQuB,QAC3CtB,EAAI0C,UAAUH,EAAQI,MAAO,EAAG,EAAG5C,EAAQW,MAAOX,EAAQuB,QAEtDiB,EAAQK,mBACR,IAAK,MAAMC,KAAaN,EAAQK,mBAG5BE,eAAe9C,EAAK6C,EAAWE,mBAAoB,CAAEC,MAAO,YAC5DF,eAAe9C,EAAK6C,EAAWI,kBAAmB,CAAED,MAAO,YAC3DF,eAAe9C,EAAK6C,EAAWK,mBAAoB,CAAEF,MAAO,YAC5DF,eAAe9C,EAAK6C,EAAWM,cAAe,CAAEH,MAAO,YAI/D,IASUI,EAGAC,EACAC,EAbNf,EAAQK,oBAA0D,EAApCL,EAAQK,mBAAmBW,SAInDC,GAHAX,EAAYN,EAAQK,mBAAmB,IAGtB,GACjBa,EAAUZ,EAAU,IACpBa,EAAWC,KAAKC,IAAIJ,EAAKK,EAAIJ,EAAQI,GAGrCT,EAAsC,GAA9BO,KAAKG,IAAI,GAAK,EAAIJ,GAG1BL,EAAII,EAAQJ,EAAItD,EAAQW,MACxB4C,EAAIG,EAAQH,EAAIvD,EAAQuB,OAG9BtB,EAAI0C,UAAUqB,EAAKV,EAAKU,EAAIrD,MAAQ0C,EAAS,EAAGE,EAAKS,EAAIzC,OAAS8B,EAAQW,EAAIrD,MAAQ0C,EAAOW,EAAIzC,OAAS8B,QAItH,MAAMW,EAAM,IAAIC,MAChBD,EAAIE,IAAM,+BAEV,MAAMC,EAAS,IAAIC,OAAOvE,EAAQ,CAC9BwE,QAASC,gBACCxC,EAASyC,KAAK,CAAE3B,MAAO/C,KAEjCc,MAAO,CAAEC,MAAO,MAChBW,OAAyB,EAAjBvB,EAAQuB,OAChBb,WAAYN,EAAQ,OAAS,gBAEjC+D,EAAOK","file":"main.min.js","sourcesContent":["$(function () {\n    const $video = document.querySelector('[data-camera-video]');\n    const $canvas = document.querySelector('[data-camera-canvas]');\n    const ctx = $canvas.getContext('2d');\n    let streamObj; // 預計用來存放 串流相關的物件(MediaStream)\n    let front = true;\n\n    // 開啟 webcam\n    openCam();\n\n    function openCam() {\n        // 開啟視訊鏡頭，瀏覽器會跳詢問視窗\n        navigator.mediaDevices.getUserMedia({\n            video: {\n                facingMode: front ? 'user' : 'environment',\n                width: { ideal: 656 * 3 }\n            }\n        }).then(function (stream) {\n            streamObj = stream;         // 將串流物件放在 streamObj 全域變數，方便後面關閉 webcam 時會用到\n            $video.srcObject = stream;  // video 標籤顯示 webcam 畫面\n            // $('[data-camera]').addClass('-open');\n        }).catch(function (error) {     // 若無法取得畫面，執行 catch\n            alert('取得相機訪問權限失敗: ', error.message, error.name);\n        });\n    }\n\n    $video.addEventListener('play', function () {\n        // 將 video 標籤的影片寬高，顯示於 canvas 標籤上\n        $canvas.width = $video.videoWidth;\n        $canvas.height = $video.videoHeight;\n        // drawCanvas();\n    }, false);\n\n    // function drawCanvas() {\n    //     // 清空Canvas\n    //     ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n    //     ctx.save();\n    //     if (front) {\n    //         // 水平反轉\n    //         ctx.translate($canvas.width, 0);\n    //         ctx.scale(-1, 1);\n    //     }\n    //     ctx.drawImage($video, 0, 0, $canvas.width, $canvas.height);\n    //     ctx.restore();\n    //     // 進行下一幀的繪製\n    //     requestAnimationFrame(drawCanvas);\n    // }\n\n    $('[data-camera-direction]').on('click', function () {\n        streamObj.getTracks().forEach(track => track.stop());\n        front = !front;\n        openCam();\n    });\n\n\n\n\n    const faceMesh = new FaceMesh({\n        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`, // 本地路徑\n    });\n\n    faceMesh.setOptions({\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5,\n    });\n\n    faceMesh.onResults(onResults);\n\n    function onResults(results) {\n        requestAnimationFrame(() => {\n            ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n            ctx.drawImage(results.image, 0, 0, $canvas.width, $canvas.height);\n\n            if (results.multiFaceLandmarks) {\n                for (const landmarks of results.multiFaceLandmarks) {\n                    // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION,\n                    //     { color: '#C0C0C070', lineWidth: 1 });\n                    drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030' });\n                    drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30' });\n                    drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0' });\n                    drawConnectors(ctx, landmarks, FACEMESH_LIPS, { color: '#E0E0E0' });\n                }\n            }\n\n            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {\n                const landmarks = results.multiFaceLandmarks[0];\n\n                // 提取頭部和相機的距離\n                const nose = landmarks[0];  // 鼻子坐標\n                const headTop = landmarks[10];  // 頭頂坐標\n                const distance = Math.abs(nose.z - headTop.z); // 計算距離\n\n                // 根據距離計算縮放比例，這裡假設距離越遠，縮放比例越小\n                const scale = Math.max(0.5, 2 - distance) * 0.1; // 設置縮放邊界\n\n                // 計算頭頂的座標\n                const x = headTop.x * $canvas.width;\n                const y = headTop.y * $canvas.height;\n\n                // 繪製頭頂的圖片，根據距離調整大小\n                ctx.drawImage(img, x - (img.width * scale) / 2, y - (img.height * scale), img.width * scale, img.height * scale);\n            }\n        });\n    }\n    const img = new Image();\n    img.src = '/assets/image/touch/logo.png'; // 你想顯示的圖片路徑\n\n    const camera = new Camera($video, {\n        onFrame: async () => {\n            await faceMesh.send({ image: $video });\n        },\n        width: { ideal: 656 * 3 },\n        height: $canvas.height * 4,\n        facingMode: front ? 'user' : 'environment'\n    });\n    camera.start();\n});"],"sourceRoot":"/"}